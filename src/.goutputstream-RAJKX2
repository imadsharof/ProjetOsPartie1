#include <iostream>
#include <string>
#include <cstring>
#include <vector>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/shm.h>

class ChatProgram {
public:
    ChatProgram() : botMode(false), manualMode(false), exitCode(0) {}
    ~ChatProgram() { cleanupPipes(); }

    bool parseArguments(int argc, char* argv[]) {
        if (argc < 3) {
            std::cerr << "chat pseudo_utilisateur pseudo_destinataire [--bot] [--manuel]" << std::endl;
            exitCode = 1;
            return false;
        }

        userPseudo = argv[1];
        destPseudo = argv[2];

        if (!validatePseudo(userPseudo) || !validatePseudo(destPseudo)) {
            return false;
        }

        for (int i = 3; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--bot") botMode = true;
            else if (arg == "--manuel") manualMode = true;
        }

        return true;
    }

    bool createPipes() {
        mode_t mode = 0666;
        if (mkfifo(getSendPipePath().c_str(), mode) == -1 && errno != EEXIST) {
            std::cerr << "Erreur lors de la création du pipe d'envoi" << std::endl;
            return false;
        }
        if (mkfifo(getReceivePipePath().c_str(), mode) == -1 && errno != EEXIST) {
            std::cerr << "Erreur lors de la création du pipe de réception" << std::endl;
            return false;
        }
        return true;
    }

    void readMessages() {
        int fd = open(getReceivePipePath().c_str(), O_RDONLY);
        if (fd == -1) return;

        char buffer[4096];
        ssize_t bytesRead;

        while ((bytesRead = read(fd, buffer, sizeof(buffer))) > 0) {
            if (manualMode) {
                std::cout << '\a' << std::flush;
                // Stockage en mémoire partagée
                int shmid = shmget(IPC_PRIVATE, 4096, IPC_CREAT | 0666);
                if (shmid != -1) {
                    char* shared_memory = (char*)shmat(shmid, NULL, 0);
                    if (shared_memory != (char*)-1) {
                        memcpy(shared_memory, buffer, bytesRead);
                        shared_memory[bytesRead] = '\0';
                        shmdt(shared_memory);
                    }
                }
            } else {
                buffer[bytesRead] = '\0';
                displayMessage(buffer, destPseudo);
            }
        }

        close(fd);
    }

    void sendMessages() {
        int fd = open(getSendPipePath().c_str(), O_WRONLY);
        if (fd == -1) return;

        std::string message;
        while (std::getline(std::cin, message)) {
            if (!botMode) {
                displayMessage(message, userPseudo);
            }
            write(fd, message.c_str(), message.length());
        }

        close(fd);
    }

    int getExitCode() const { return exitCode; }

    static void handleSignal(int signal) {
        static bool pipesOpened = false;

        if (signal == SIGINT) {
            if (!pipesOpened) {
                exit(4);
            }
            // Afficher les messages en attente si en mode manuel
        } else if (signal == SIGPIPE) {
            exit(0);
        }
    }

private:
    std::string userPseudo;
    std::string destPseudo;
    bool botMode;
    bool manualMode;
    int exitCode;

    std::string getSendPipePath() const {
        return "/tmp/" + userPseudo + "-" + destPseudo + ".chat";
    }

    std::string getReceivePipePath() const {
        return "/tmp/" + destPseudo + "-" + userPseudo + ".chat";
    }

    bool validatePseudo(const std::string& pseudo) const {
        if (pseudo.length() > 30) {
            std::cerr << "Le pseudo ne doit pas dépasser 30 caractères" << std::endl;
            exitCode = 2;
            return false;
        }

        if (pseudo == "." || pseudo == "..") {
            std::cerr << "Pseudo invalide" << std::endl;
            exitCode = 3;
            return false;
        }

        const std::string invalidChars = "/[]";
        if (pseudo.find_first_of(invalidChars) != std::string::npos) {
            std::cerr << "Le pseudo contient des caractères invalides" << std::endl;
            exitCode = 3;
            return false;
        }

        return true;
    }

    void displayMessage(const std::string& message, const std::string& sender) {
        if (!botMode) {
            std::cout << "[";
            if (!botMode) std::cout << "\x1B[4m";
            std::cout << sender;
            if (!botMode) std::cout << "\x1B[0m";
            std::cout << "] " << message << std::endl;
        }
    }

    void cleanupPipes() {
        unlink(getSendPipePath().c_str());
        unlink(getReceivePipePath().c_str());
    }
};

int main(int argc, char* argv[]) {
    ChatProgram chat;
    
    if (!chat.parseArguments(argc, argv)) {
        return chat.getExitCode();
    }

    signal(SIGINT, ChatProgram::handleSignal);
    signal(SIGPIPE, ChatProgram::handleSignal);

    if (!chat.createPipes()) {
        return chat.getExitCode();
    }

    pid_t pid = fork();
    if (pid < 0) {
        std::cerr << "Erreur lors de la création du processus fils" << std::endl;
        return 4;
    }

    if (pid == 0) {
        chat.readMessages();
    } else {
        chat.sendMessages();
        wait(NULL);
    }

    return 0;
}
